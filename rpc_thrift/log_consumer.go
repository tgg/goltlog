// Autogenerated by Thrift Compiler (0.9.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package rpc_thrift

import (
	"fmt"
	"git-wip-us.apache.org/repos/asf/thrift.git/lib/go/thrift"
	"math"
)

// (needed to ensure safety because of naive import list construction.)
var _ = math.MinInt32
var _ = thrift.ZERO
var _ = fmt.Printf

type LogConsumer interface {
	LogAdministrator

	// Parameters:
	//  - FromTime
	GetRecordIdFromTime(fromTime *LogTime) (r RecordId, err error)
	// Parameters:
	//  - CurrentId
	//  - HowMany
	RetrieveRecords(currentId RecordId, howMany U32) (r *RecordIdU32LogRecordSequence, err error)
	// Parameters:
	//  - CurrentId
	//  - HowMany
	//  - ValueList
	RetrieveRecordsByLevel(currentId RecordId, howMany U32, valueList LogLevelSequence) (r *RecordIdU32LogRecordSequence, err error)
	// Parameters:
	//  - CurrentId
	//  - HowMany
	//  - ValueList
	RetrieveRecordsByProducerId(currentId RecordId, howMany U32, valueList StringSeq) (r *RecordIdU32LogRecordSequence, err error)
	// Parameters:
	//  - CurrentId
	//  - HowMany
	//  - ValueList
	RetrieveRecordsByProducerName(currentId RecordId, howMany U32, valueList StringSeq) (r *RecordIdU32LogRecordSequence, err error)
}

type LogConsumerClient struct {
	*LogAdministratorClient
}

func NewLogConsumerClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *LogConsumerClient {
	return &LogConsumerClient{LogAdministratorClient: NewLogAdministratorClientFactory(t, f)}
}

func NewLogConsumerClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *LogConsumerClient {
	return &LogConsumerClient{LogAdministratorClient: NewLogAdministratorClientProtocol(t, iprot, oprot)}
}

// Parameters:
//  - FromTime
func (p *LogConsumerClient) GetRecordIdFromTime(fromTime *LogTime) (r RecordId, err error) {
	if err = p.sendGetRecordIdFromTime(fromTime); err != nil {
		return
	}
	return p.recvGetRecordIdFromTime()
}

func (p *LogConsumerClient) sendGetRecordIdFromTime(fromTime *LogTime) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_record_id_from_time", thrift.CALL, p.SeqId)
	args53 := NewGetRecordIdFromTimeArgs()
	args53.FromTime = fromTime
	err = args53.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *LogConsumerClient) recvGetRecordIdFromTime() (value RecordId, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error55 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error56 error
		error56, err = error55.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error56
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result54 := NewGetRecordIdFromTimeResult()
	err = result54.Read(iprot)
	iprot.ReadMessageEnd()
	value = result54.Success
	return
}

// Parameters:
//  - CurrentId
//  - HowMany
func (p *LogConsumerClient) RetrieveRecords(currentId RecordId, howMany U32) (r *RecordIdU32LogRecordSequence, err error) {
	if err = p.sendRetrieveRecords(currentId, howMany); err != nil {
		return
	}
	return p.recvRetrieveRecords()
}

func (p *LogConsumerClient) sendRetrieveRecords(currentId RecordId, howMany U32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("retrieve_records", thrift.CALL, p.SeqId)
	args57 := NewRetrieveRecordsArgs()
	args57.CurrentId = currentId
	args57.HowMany = howMany
	err = args57.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *LogConsumerClient) recvRetrieveRecords() (value *RecordIdU32LogRecordSequence, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error59 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error60 error
		error60, err = error59.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error60
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result58 := NewRetrieveRecordsResult()
	err = result58.Read(iprot)
	iprot.ReadMessageEnd()
	value = result58.Success
	return
}

// Parameters:
//  - CurrentId
//  - HowMany
//  - ValueList
func (p *LogConsumerClient) RetrieveRecordsByLevel(currentId RecordId, howMany U32, valueList LogLevelSequence) (r *RecordIdU32LogRecordSequence, err error) {
	if err = p.sendRetrieveRecordsByLevel(currentId, howMany, valueList); err != nil {
		return
	}
	return p.recvRetrieveRecordsByLevel()
}

func (p *LogConsumerClient) sendRetrieveRecordsByLevel(currentId RecordId, howMany U32, valueList LogLevelSequence) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("retrieve_records_by_level", thrift.CALL, p.SeqId)
	args61 := NewRetrieveRecordsByLevelArgs()
	args61.CurrentId = currentId
	args61.HowMany = howMany
	args61.ValueList = valueList
	err = args61.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *LogConsumerClient) recvRetrieveRecordsByLevel() (value *RecordIdU32LogRecordSequence, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error63 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error64 error
		error64, err = error63.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error64
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result62 := NewRetrieveRecordsByLevelResult()
	err = result62.Read(iprot)
	iprot.ReadMessageEnd()
	value = result62.Success
	return
}

// Parameters:
//  - CurrentId
//  - HowMany
//  - ValueList
func (p *LogConsumerClient) RetrieveRecordsByProducerId(currentId RecordId, howMany U32, valueList StringSeq) (r *RecordIdU32LogRecordSequence, err error) {
	if err = p.sendRetrieveRecordsByProducerId(currentId, howMany, valueList); err != nil {
		return
	}
	return p.recvRetrieveRecordsByProducerId()
}

func (p *LogConsumerClient) sendRetrieveRecordsByProducerId(currentId RecordId, howMany U32, valueList StringSeq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("retrieve_records_by_producer_id", thrift.CALL, p.SeqId)
	args65 := NewRetrieveRecordsByProducerIdArgs()
	args65.CurrentId = currentId
	args65.HowMany = howMany
	args65.ValueList = valueList
	err = args65.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *LogConsumerClient) recvRetrieveRecordsByProducerId() (value *RecordIdU32LogRecordSequence, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error67 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error68 error
		error68, err = error67.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error68
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result66 := NewRetrieveRecordsByProducerIdResult()
	err = result66.Read(iprot)
	iprot.ReadMessageEnd()
	value = result66.Success
	return
}

// Parameters:
//  - CurrentId
//  - HowMany
//  - ValueList
func (p *LogConsumerClient) RetrieveRecordsByProducerName(currentId RecordId, howMany U32, valueList StringSeq) (r *RecordIdU32LogRecordSequence, err error) {
	if err = p.sendRetrieveRecordsByProducerName(currentId, howMany, valueList); err != nil {
		return
	}
	return p.recvRetrieveRecordsByProducerName()
}

func (p *LogConsumerClient) sendRetrieveRecordsByProducerName(currentId RecordId, howMany U32, valueList StringSeq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("retrieve_records_by_producer_name", thrift.CALL, p.SeqId)
	args69 := NewRetrieveRecordsByProducerNameArgs()
	args69.CurrentId = currentId
	args69.HowMany = howMany
	args69.ValueList = valueList
	err = args69.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *LogConsumerClient) recvRetrieveRecordsByProducerName() (value *RecordIdU32LogRecordSequence, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error71 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error72 error
		error72, err = error71.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error72
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result70 := NewRetrieveRecordsByProducerNameResult()
	err = result70.Read(iprot)
	iprot.ReadMessageEnd()
	value = result70.Success
	return
}

type LogConsumerProcessor struct {
	*LogAdministratorProcessor
}

func NewLogConsumerProcessor(handler LogConsumer) *LogConsumerProcessor {
	self73 := &LogConsumerProcessor{NewLogAdministratorProcessor(handler)}
	self73.AddToProcessorMap("get_record_id_from_time", &logConsumerProcessorGetRecordIdFromTime{handler: handler})
	self73.AddToProcessorMap("retrieve_records", &logConsumerProcessorRetrieveRecords{handler: handler})
	self73.AddToProcessorMap("retrieve_records_by_level", &logConsumerProcessorRetrieveRecordsByLevel{handler: handler})
	self73.AddToProcessorMap("retrieve_records_by_producer_id", &logConsumerProcessorRetrieveRecordsByProducerId{handler: handler})
	self73.AddToProcessorMap("retrieve_records_by_producer_name", &logConsumerProcessorRetrieveRecordsByProducerName{handler: handler})
	return self73
}

type logConsumerProcessorGetRecordIdFromTime struct {
	handler LogConsumer
}

func (p *logConsumerProcessorGetRecordIdFromTime) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRecordIdFromTimeArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_record_id_from_time", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRecordIdFromTimeResult()
	if result.Success, err = p.handler.GetRecordIdFromTime(args.FromTime); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_record_id_from_time: "+err.Error())
		oprot.WriteMessageBegin("get_record_id_from_time", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_record_id_from_time", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type logConsumerProcessorRetrieveRecords struct {
	handler LogConsumer
}

func (p *logConsumerProcessorRetrieveRecords) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRetrieveRecordsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("retrieve_records", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRetrieveRecordsResult()
	if result.Success, err = p.handler.RetrieveRecords(args.CurrentId, args.HowMany); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing retrieve_records: "+err.Error())
		oprot.WriteMessageBegin("retrieve_records", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("retrieve_records", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type logConsumerProcessorRetrieveRecordsByLevel struct {
	handler LogConsumer
}

func (p *logConsumerProcessorRetrieveRecordsByLevel) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRetrieveRecordsByLevelArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("retrieve_records_by_level", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRetrieveRecordsByLevelResult()
	if result.Success, err = p.handler.RetrieveRecordsByLevel(args.CurrentId, args.HowMany, args.ValueList); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing retrieve_records_by_level: "+err.Error())
		oprot.WriteMessageBegin("retrieve_records_by_level", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("retrieve_records_by_level", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type logConsumerProcessorRetrieveRecordsByProducerId struct {
	handler LogConsumer
}

func (p *logConsumerProcessorRetrieveRecordsByProducerId) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRetrieveRecordsByProducerIdArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("retrieve_records_by_producer_id", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRetrieveRecordsByProducerIdResult()
	if result.Success, err = p.handler.RetrieveRecordsByProducerId(args.CurrentId, args.HowMany, args.ValueList); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing retrieve_records_by_producer_id: "+err.Error())
		oprot.WriteMessageBegin("retrieve_records_by_producer_id", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("retrieve_records_by_producer_id", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type logConsumerProcessorRetrieveRecordsByProducerName struct {
	handler LogConsumer
}

func (p *logConsumerProcessorRetrieveRecordsByProducerName) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRetrieveRecordsByProducerNameArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("retrieve_records_by_producer_name", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRetrieveRecordsByProducerNameResult()
	if result.Success, err = p.handler.RetrieveRecordsByProducerName(args.CurrentId, args.HowMany, args.ValueList); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing retrieve_records_by_producer_name: "+err.Error())
		oprot.WriteMessageBegin("retrieve_records_by_producer_name", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("retrieve_records_by_producer_name", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type GetRecordIdFromTimeArgs struct {
	FromTime *LogTime `thrift:"fromTime,1"`
}

func NewGetRecordIdFromTimeArgs() *GetRecordIdFromTimeArgs {
	return &GetRecordIdFromTimeArgs{}
}

func (p *GetRecordIdFromTimeArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRecordIdFromTimeArgs) readField1(iprot thrift.TProtocol) error {
	p.FromTime = NewLogTime()
	if err := p.FromTime.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.FromTime)
	}
	return nil
}

func (p *GetRecordIdFromTimeArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_record_id_from_time_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRecordIdFromTimeArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.FromTime != nil {
		if err := oprot.WriteFieldBegin("fromTime", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:fromTime: %s", p, err)
		}
		if err := p.FromTime.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.FromTime)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:fromTime: %s", p, err)
		}
	}
	return err
}

func (p *GetRecordIdFromTimeArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRecordIdFromTimeArgs(%+v)", *p)
}

type GetRecordIdFromTimeResult struct {
	Success RecordId `thrift:"success,0"`
}

func NewGetRecordIdFromTimeResult() *GetRecordIdFromTimeResult {
	return &GetRecordIdFromTimeResult{}
}

func (p *GetRecordIdFromTimeResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRecordIdFromTimeResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = RecordId(v)
	}
	return nil
}

func (p *GetRecordIdFromTimeResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_record_id_from_time_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRecordIdFromTimeResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetRecordIdFromTimeResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRecordIdFromTimeResult(%+v)", *p)
}

type RetrieveRecordsArgs struct {
	CurrentId RecordId `thrift:"currentId,1"`
	HowMany   U32      `thrift:"howMany,2"`
}

func NewRetrieveRecordsArgs() *RetrieveRecordsArgs {
	return &RetrieveRecordsArgs{}
}

func (p *RetrieveRecordsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RetrieveRecordsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.CurrentId = RecordId(v)
	}
	return nil
}

func (p *RetrieveRecordsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.HowMany = U32(v)
	}
	return nil
}

func (p *RetrieveRecordsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("retrieve_records_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RetrieveRecordsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("currentId", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:currentId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.CurrentId)); err != nil {
		return fmt.Errorf("%T.currentId (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:currentId: %s", p, err)
	}
	return err
}

func (p *RetrieveRecordsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("howMany", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:howMany: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.HowMany)); err != nil {
		return fmt.Errorf("%T.howMany (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:howMany: %s", p, err)
	}
	return err
}

func (p *RetrieveRecordsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RetrieveRecordsArgs(%+v)", *p)
}

type RetrieveRecordsResult struct {
	Success *RecordIdU32LogRecordSequence `thrift:"success,0"`
}

func NewRetrieveRecordsResult() *RetrieveRecordsResult {
	return &RetrieveRecordsResult{}
}

func (p *RetrieveRecordsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RetrieveRecordsResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewRecordIdU32LogRecordSequence()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *RetrieveRecordsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("retrieve_records_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RetrieveRecordsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *RetrieveRecordsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RetrieveRecordsResult(%+v)", *p)
}

type RetrieveRecordsByLevelArgs struct {
	CurrentId RecordId         `thrift:"currentId,1"`
	HowMany   U32              `thrift:"howMany,2"`
	ValueList LogLevelSequence `thrift:"valueList,3"`
}

func NewRetrieveRecordsByLevelArgs() *RetrieveRecordsByLevelArgs {
	return &RetrieveRecordsByLevelArgs{}
}

func (p *RetrieveRecordsByLevelArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RetrieveRecordsByLevelArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.CurrentId = RecordId(v)
	}
	return nil
}

func (p *RetrieveRecordsByLevelArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.HowMany = U32(v)
	}
	return nil
}

func (p *RetrieveRecordsByLevelArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.ValueList = make([]LogLevel, 0, size)
	for i := 0; i < size; i++ {
		var _elem74 LogLevel
		if v, err := iprot.ReadI16(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem74 = LogLevel(v)
		}
		p.ValueList = append(p.ValueList, _elem74)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *RetrieveRecordsByLevelArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("retrieve_records_by_level_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RetrieveRecordsByLevelArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("currentId", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:currentId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.CurrentId)); err != nil {
		return fmt.Errorf("%T.currentId (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:currentId: %s", p, err)
	}
	return err
}

func (p *RetrieveRecordsByLevelArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("howMany", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:howMany: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.HowMany)); err != nil {
		return fmt.Errorf("%T.howMany (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:howMany: %s", p, err)
	}
	return err
}

func (p *RetrieveRecordsByLevelArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.ValueList != nil {
		if err := oprot.WriteFieldBegin("valueList", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:valueList: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.I16, len(p.ValueList)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.ValueList {
			if err := oprot.WriteI16(int16(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:valueList: %s", p, err)
		}
	}
	return err
}

func (p *RetrieveRecordsByLevelArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RetrieveRecordsByLevelArgs(%+v)", *p)
}

type RetrieveRecordsByLevelResult struct {
	Success *RecordIdU32LogRecordSequence `thrift:"success,0"`
}

func NewRetrieveRecordsByLevelResult() *RetrieveRecordsByLevelResult {
	return &RetrieveRecordsByLevelResult{}
}

func (p *RetrieveRecordsByLevelResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RetrieveRecordsByLevelResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewRecordIdU32LogRecordSequence()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *RetrieveRecordsByLevelResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("retrieve_records_by_level_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RetrieveRecordsByLevelResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *RetrieveRecordsByLevelResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RetrieveRecordsByLevelResult(%+v)", *p)
}

type RetrieveRecordsByProducerIdArgs struct {
	CurrentId RecordId  `thrift:"currentId,1"`
	HowMany   U32       `thrift:"howMany,2"`
	ValueList StringSeq `thrift:"valueList,3"`
}

func NewRetrieveRecordsByProducerIdArgs() *RetrieveRecordsByProducerIdArgs {
	return &RetrieveRecordsByProducerIdArgs{}
}

func (p *RetrieveRecordsByProducerIdArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RetrieveRecordsByProducerIdArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.CurrentId = RecordId(v)
	}
	return nil
}

func (p *RetrieveRecordsByProducerIdArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.HowMany = U32(v)
	}
	return nil
}

func (p *RetrieveRecordsByProducerIdArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.ValueList = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem75 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem75 = v
		}
		p.ValueList = append(p.ValueList, _elem75)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *RetrieveRecordsByProducerIdArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("retrieve_records_by_producer_id_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RetrieveRecordsByProducerIdArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("currentId", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:currentId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.CurrentId)); err != nil {
		return fmt.Errorf("%T.currentId (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:currentId: %s", p, err)
	}
	return err
}

func (p *RetrieveRecordsByProducerIdArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("howMany", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:howMany: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.HowMany)); err != nil {
		return fmt.Errorf("%T.howMany (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:howMany: %s", p, err)
	}
	return err
}

func (p *RetrieveRecordsByProducerIdArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.ValueList != nil {
		if err := oprot.WriteFieldBegin("valueList", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:valueList: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.ValueList)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.ValueList {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:valueList: %s", p, err)
		}
	}
	return err
}

func (p *RetrieveRecordsByProducerIdArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RetrieveRecordsByProducerIdArgs(%+v)", *p)
}

type RetrieveRecordsByProducerIdResult struct {
	Success *RecordIdU32LogRecordSequence `thrift:"success,0"`
}

func NewRetrieveRecordsByProducerIdResult() *RetrieveRecordsByProducerIdResult {
	return &RetrieveRecordsByProducerIdResult{}
}

func (p *RetrieveRecordsByProducerIdResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RetrieveRecordsByProducerIdResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewRecordIdU32LogRecordSequence()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *RetrieveRecordsByProducerIdResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("retrieve_records_by_producer_id_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RetrieveRecordsByProducerIdResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *RetrieveRecordsByProducerIdResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RetrieveRecordsByProducerIdResult(%+v)", *p)
}

type RetrieveRecordsByProducerNameArgs struct {
	CurrentId RecordId  `thrift:"currentId,1"`
	HowMany   U32       `thrift:"howMany,2"`
	ValueList StringSeq `thrift:"valueList,3"`
}

func NewRetrieveRecordsByProducerNameArgs() *RetrieveRecordsByProducerNameArgs {
	return &RetrieveRecordsByProducerNameArgs{}
}

func (p *RetrieveRecordsByProducerNameArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RetrieveRecordsByProducerNameArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.CurrentId = RecordId(v)
	}
	return nil
}

func (p *RetrieveRecordsByProducerNameArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.HowMany = U32(v)
	}
	return nil
}

func (p *RetrieveRecordsByProducerNameArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.ValueList = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem76 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem76 = v
		}
		p.ValueList = append(p.ValueList, _elem76)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *RetrieveRecordsByProducerNameArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("retrieve_records_by_producer_name_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RetrieveRecordsByProducerNameArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("currentId", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:currentId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.CurrentId)); err != nil {
		return fmt.Errorf("%T.currentId (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:currentId: %s", p, err)
	}
	return err
}

func (p *RetrieveRecordsByProducerNameArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("howMany", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:howMany: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.HowMany)); err != nil {
		return fmt.Errorf("%T.howMany (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:howMany: %s", p, err)
	}
	return err
}

func (p *RetrieveRecordsByProducerNameArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.ValueList != nil {
		if err := oprot.WriteFieldBegin("valueList", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:valueList: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.ValueList)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.ValueList {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:valueList: %s", p, err)
		}
	}
	return err
}

func (p *RetrieveRecordsByProducerNameArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RetrieveRecordsByProducerNameArgs(%+v)", *p)
}

type RetrieveRecordsByProducerNameResult struct {
	Success *RecordIdU32LogRecordSequence `thrift:"success,0"`
}

func NewRetrieveRecordsByProducerNameResult() *RetrieveRecordsByProducerNameResult {
	return &RetrieveRecordsByProducerNameResult{}
}

func (p *RetrieveRecordsByProducerNameResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RetrieveRecordsByProducerNameResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewRecordIdU32LogRecordSequence()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *RetrieveRecordsByProducerNameResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("retrieve_records_by_producer_name_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RetrieveRecordsByProducerNameResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *RetrieveRecordsByProducerNameResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RetrieveRecordsByProducerNameResult(%+v)", *p)
}
