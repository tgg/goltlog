// Autogenerated by Thrift Compiler (0.9.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package rpc_thrift

import (
	"fmt"
	"git-wip-us.apache.org/repos/asf/thrift.git/lib/go/thrift"
	"math"
)

// (needed to ensure safety because of naive import list construction.)
var _ = math.MinInt32
var _ = thrift.ZERO
var _ = fmt.Printf

var GoUnusedProtection__ int

type OperationalState int64

const (
	OperationalState_disabled OperationalState = 0
	OperationalState_enabled  OperationalState = 1
)

func (p OperationalState) String() string {
	switch p {
	case OperationalState_disabled:
		return "OperationalState_disabled"
	case OperationalState_enabled:
		return "OperationalState_enabled"
	}
	return "<UNSET>"
}

func OperationalStateFromString(s string) (OperationalState, error) {
	switch s {
	case "OperationalState_disabled":
		return OperationalState_disabled, nil
	case "OperationalState_enabled":
		return OperationalState_enabled, nil
	}
	return OperationalState(math.MinInt32 - 1), fmt.Errorf("not a valid OperationalState string")
}

type AdministrativeState int64

const (
	AdministrativeState_locked   AdministrativeState = 0
	AdministrativeState_unlocked AdministrativeState = 1
)

func (p AdministrativeState) String() string {
	switch p {
	case AdministrativeState_locked:
		return "AdministrativeState_locked"
	case AdministrativeState_unlocked:
		return "AdministrativeState_unlocked"
	}
	return "<UNSET>"
}

func AdministrativeStateFromString(s string) (AdministrativeState, error) {
	switch s {
	case "AdministrativeState_locked":
		return AdministrativeState_locked, nil
	case "AdministrativeState_unlocked":
		return AdministrativeState_unlocked, nil
	}
	return AdministrativeState(math.MinInt32 - 1), fmt.Errorf("not a valid AdministrativeState string")
}

type LogFullAction int64

const (
	LogFullAction_WRAP LogFullAction = 0
	LogFullAction_HALT LogFullAction = 1
)

func (p LogFullAction) String() string {
	switch p {
	case LogFullAction_WRAP:
		return "LogFullAction_WRAP"
	case LogFullAction_HALT:
		return "LogFullAction_HALT"
	}
	return "<UNSET>"
}

func LogFullActionFromString(s string) (LogFullAction, error) {
	switch s {
	case "LogFullAction_WRAP":
		return LogFullAction_WRAP, nil
	case "LogFullAction_HALT":
		return LogFullAction_HALT, nil
	}
	return LogFullAction(math.MinInt32 - 1), fmt.Errorf("not a valid LogFullAction string")
}

type U16 int16

type U32 int32

type U64 int64

type LogLevel U16

type RecordId U64

type LogRecordSequence []*LogRecord

type ProducerLogRecordSequence []*ProducerLogRecord

type LogLevelSequence []LogLevel

type StringSeq []string

type LogTime struct {
	Seconds     int32 `thrift:"seconds,1"`
	Nanoseconds int32 `thrift:"nanoseconds,2"`
}

func NewLogTime() *LogTime {
	return &LogTime{}
}

func (p *LogTime) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LogTime) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Seconds = v
	}
	return nil
}

func (p *LogTime) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Nanoseconds = v
	}
	return nil
}

func (p *LogTime) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("LogTime"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *LogTime) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("seconds", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:seconds: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Seconds)); err != nil {
		return fmt.Errorf("%T.seconds (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:seconds: %s", p, err)
	}
	return err
}

func (p *LogTime) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("nanoseconds", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:nanoseconds: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Nanoseconds)); err != nil {
		return fmt.Errorf("%T.nanoseconds (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:nanoseconds: %s", p, err)
	}
	return err
}

func (p *LogTime) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LogTime(%+v)", *p)
}

type AvailabilityStatus struct {
	OffDuty bool `thrift:"off_duty,1"`
	LogFull bool `thrift:"log_full,2"`
}

func NewAvailabilityStatus() *AvailabilityStatus {
	return &AvailabilityStatus{}
}

func (p *AvailabilityStatus) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AvailabilityStatus) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.OffDuty = v
	}
	return nil
}

func (p *AvailabilityStatus) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.LogFull = v
	}
	return nil
}

func (p *AvailabilityStatus) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AvailabilityStatus"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AvailabilityStatus) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("off_duty", thrift.BOOL, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:off_duty: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.OffDuty)); err != nil {
		return fmt.Errorf("%T.off_duty (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:off_duty: %s", p, err)
	}
	return err
}

func (p *AvailabilityStatus) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("log_full", thrift.BOOL, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:log_full: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.LogFull)); err != nil {
		return fmt.Errorf("%T.log_full (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:log_full: %s", p, err)
	}
	return err
}

func (p *AvailabilityStatus) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AvailabilityStatus(%+v)", *p)
}

type ProducerLogRecord struct {
	ProducerId   string   `thrift:"producerId,1"`
	ProducerName string   `thrift:"producerName,2"`
	Level        LogLevel `thrift:"level,3"`
	LogData      string   `thrift:"logData,4"`
}

func NewProducerLogRecord() *ProducerLogRecord {
	return &ProducerLogRecord{}
}

func (p *ProducerLogRecord) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ProducerLogRecord) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ProducerId = v
	}
	return nil
}

func (p *ProducerLogRecord) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.ProducerName = v
	}
	return nil
}

func (p *ProducerLogRecord) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI16(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Level = LogLevel(v)
	}
	return nil
}

func (p *ProducerLogRecord) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.LogData = v
	}
	return nil
}

func (p *ProducerLogRecord) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ProducerLogRecord"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ProducerLogRecord) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("producerId", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:producerId: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ProducerId)); err != nil {
		return fmt.Errorf("%T.producerId (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:producerId: %s", p, err)
	}
	return err
}

func (p *ProducerLogRecord) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("producerName", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:producerName: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ProducerName)); err != nil {
		return fmt.Errorf("%T.producerName (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:producerName: %s", p, err)
	}
	return err
}

func (p *ProducerLogRecord) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("level", thrift.I16, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:level: %s", p, err)
	}
	if err := oprot.WriteI16(int16(p.Level)); err != nil {
		return fmt.Errorf("%T.level (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:level: %s", p, err)
	}
	return err
}

func (p *ProducerLogRecord) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("logData", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:logData: %s", p, err)
	}
	if err := oprot.WriteString(string(p.LogData)); err != nil {
		return fmt.Errorf("%T.logData (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:logData: %s", p, err)
	}
	return err
}

func (p *ProducerLogRecord) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ProducerLogRecord(%+v)", *p)
}

type LogRecord struct {
	Id   RecordId           `thrift:"id,1"`
	Time *LogTime           `thrift:"time,2"`
	Info *ProducerLogRecord `thrift:"info,3"`
}

func NewLogRecord() *LogRecord {
	return &LogRecord{}
}

func (p *LogRecord) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LogRecord) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Id = RecordId(v)
	}
	return nil
}

func (p *LogRecord) readField2(iprot thrift.TProtocol) error {
	p.Time = NewLogTime()
	if err := p.Time.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Time)
	}
	return nil
}

func (p *LogRecord) readField3(iprot thrift.TProtocol) error {
	p.Info = NewProducerLogRecord()
	if err := p.Info.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Info)
	}
	return nil
}

func (p *LogRecord) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("LogRecord"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *LogRecord) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *LogRecord) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Time != nil {
		if err := oprot.WriteFieldBegin("time", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:time: %s", p, err)
		}
		if err := p.Time.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Time)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:time: %s", p, err)
		}
	}
	return err
}

func (p *LogRecord) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Info != nil {
		if err := oprot.WriteFieldBegin("info", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:info: %s", p, err)
		}
		if err := p.Info.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Info)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:info: %s", p, err)
		}
	}
	return err
}

func (p *LogRecord) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LogRecord(%+v)", *p)
}

type InvalidParam struct {
	Details string `thrift:"details,1"`
}

func NewInvalidParam() *InvalidParam {
	return &InvalidParam{}
}

func (p *InvalidParam) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InvalidParam) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Details = v
	}
	return nil
}

func (p *InvalidParam) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("InvalidParam"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *InvalidParam) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("details", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:details: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Details)); err != nil {
		return fmt.Errorf("%T.details (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:details: %s", p, err)
	}
	return err
}

func (p *InvalidParam) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InvalidParam(%+v)", *p)
}

type RecordIdU32LogRecordSequence struct {
	CurrentId RecordId          `thrift:"currentId,1"`
	HowMany   U32               `thrift:"howMany,2"`
	Result    LogRecordSequence `thrift:"result,3"`
}

func NewRecordIdU32LogRecordSequence() *RecordIdU32LogRecordSequence {
	return &RecordIdU32LogRecordSequence{}
}

func (p *RecordIdU32LogRecordSequence) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RecordIdU32LogRecordSequence) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.CurrentId = RecordId(v)
	}
	return nil
}

func (p *RecordIdU32LogRecordSequence) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.HowMany = U32(v)
	}
	return nil
}

func (p *RecordIdU32LogRecordSequence) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Result = make([]*LogRecord, 0, size)
	for i := 0; i < size; i++ {
		_elem0 := NewLogRecord()
		if err := _elem0.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem0)
		}
		p.Result = append(p.Result, _elem0)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *RecordIdU32LogRecordSequence) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("RecordIdU32LogRecordSequence"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RecordIdU32LogRecordSequence) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("currentId", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:currentId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.CurrentId)); err != nil {
		return fmt.Errorf("%T.currentId (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:currentId: %s", p, err)
	}
	return err
}

func (p *RecordIdU32LogRecordSequence) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("howMany", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:howMany: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.HowMany)); err != nil {
		return fmt.Errorf("%T.howMany (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:howMany: %s", p, err)
	}
	return err
}

func (p *RecordIdU32LogRecordSequence) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Result != nil {
		if err := oprot.WriteFieldBegin("result", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:result: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Result)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Result {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:result: %s", p, err)
		}
	}
	return err
}

func (p *RecordIdU32LogRecordSequence) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RecordIdU32LogRecordSequence(%+v)", *p)
}
